<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AIKW Particle Reveal (2D Fixed)</title>
    <style>
      :root {
        color-scheme: dark;
      }
      * { box-sizing: border-box; }
      html, body {
        margin: 0; height: 100%; overflow: hidden;
        background: radial-gradient(circle at center, #101223 0%, #05060a 60%, #020207 100%);
        font-family: "Space Grotesk", "Noto Sans JP", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      }
      canvas { width: 100vw; height: 100vh; display: block; }
      .overlay { position: fixed; inset: 0; display: grid; place-items: center; pointer-events: none; }
      .overlay h1 { margin: 0; font-size: clamp(3rem, 8vw, 8rem); letter-spacing: 0.25em; color: rgba(241,241,241,0.06); text-transform: uppercase; }
      .hint { position: fixed; left: 50%; bottom: 3vh; transform: translateX(-50%); color: rgba(138,141,255,0.5); letter-spacing: .35em; font-size: .9rem; pointer-events: none; }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
    <div class="overlay"><h1>AIKW</h1></div>
    <div class="hint">Hover / Touch to stir</div>

    <script>
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d');

      const state = {
        particles: [],
        targets: [],
        // tune
        density: 0.08,       // lower = denser sampling
        jitter: 0.2,         // Brownian noise strength
        attraction: 0.09,    // pull toward targets
        drag: 0.9,           // velocity damping
        bgAlpha: 0.08,       // motion trail
        chars: 'AIKW/\\-_Â·^:=+*',
        mouse: { x: 0, y: 0, active: false },
        start: performance.now(),
        formationMs: 9000,
        maxParticles: 3200,  // cap to keep 2D path smooth
      };

      const dpr = () => window.devicePixelRatio || 1;
      const off = document.createElement('canvas');
      const offCtx = off.getContext('2d');

      function resize() {
        const { innerWidth:w, innerHeight:h } = window;
        const r = dpr();
        canvas.width = Math.floor(w * r);
        canvas.height = Math.floor(h * r);
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        ctx.setTransform(r, 0, 0, r, 0, 0);
        sampleTargets(w, h);
        syncParticles();
      }

      function sampleTargets(w, h) {
        const r = dpr();
        const fontSize = Math.min(w * 0.5, h * 0.35);
        off.width = Math.floor(w * r);
        off.height = Math.floor(h * r);
        offCtx.save();
        offCtx.scale(r, r);
        offCtx.clearRect(0, 0, w, h);
        offCtx.fillStyle = '#fff';
        offCtx.textAlign = 'center';
        offCtx.textBaseline = 'middle';
        offCtx.font = `900 ${fontSize}px \"Space Grotesk\", \"Arial Black\", system-ui`;
        // Slight stroke + fill for thicker sampling
        offCtx.lineWidth = Math.max(2, fontSize * 0.02);
        offCtx.strokeStyle = '#fff';
        offCtx.strokeText('AIKW', w/2, h/2);
        offCtx.fillText('AIKW', w/2, h/2);
        offCtx.restore();

        // Read alpha once; optionally thin by step, then cap to maxParticles
        const img = offCtx.getImageData(0, 0, off.width, off.height).data;
        const step = Math.max(3, Math.round(1 / state.density));
        const pts = [];
        for (let y = 0; y < off.height; y += step) {
          for (let x = 0; x < off.width; x += step) {
            const a = img[(y * off.width + x) * 4 + 3];
            if (a > 128) pts.push({ x: x / r, y: y / r });
          }
        }
        // Downsample to cap
        const cap = state.maxParticles;
        let chosen = pts;
        if (pts.length > cap) {
          const stride = Math.ceil(pts.length / cap);
          const offset = Math.floor(Math.random() * stride);
          chosen = [];
          for (let i = offset; i < pts.length; i += stride) chosen.push(pts[i]);
        }
        // Organically jitter around the outline
        const buf = Math.max(fontSize * 0.08, 24);
        state.targets = chosen.map(p => ({
          x: p.x + (Math.random() - 0.5) * buf,
          y: p.y + (Math.random() - 0.5) * buf * 0.35,
        }));
      }

      function syncParticles() {
        const w = canvas.width / dpr();
        const h = canvas.height / dpr();
        const n = state.targets.length;
        if (state.particles.length > n) state.particles.length = n;
        while (state.particles.length < n) {
          state.particles.push(makeParticle(Math.random()*w, Math.random()*h));
        }
        state.particles.forEach((p, i) => {
          const t = state.targets[i % n];
          p.tx = t.x; p.ty = t.y;
          // assign target glyphs more often from "AIKW"
          p.targetChar = 'AIKW'[i % 4];
        });
      }

      function makeParticle(x, y) {
        return {
          x, y,
          vx: (Math.random()-0.5)*2,
          vy: (Math.random()-0.5)*2,
          size: 9 + Math.random()*6,
          char: pickChar(state.chars),
          targetChar: null,
          tx: x, ty: y,
          rot: 0,
          rotSpd: (Math.random()-0.5)*0.02, // smaller rotation to reduce re-raster ops
          glow: Math.random() < 0.18,       // only some particles use glow styling
          op: 0.75 + Math.random()*0.25,
        };
      }

      function pickChar(s) { return s[Math.floor(Math.random()*s.length)]; }
      function rand(min, max) { return Math.random()*(max-min)+min; }

      function update(p) {
        const elapsed = performance.now() - state.start;
        const prog = Math.min(elapsed / state.formationMs, 1);

        // occasional morph toward target glyph during formation
        if (prog > 0.25 && p.targetChar && Math.random() < prog * 0.02) p.char = p.targetChar;

        const dx = p.tx - p.x, dy = p.ty - p.y;
        const dist = Math.hypot(dx, dy) || 1;
        const attract = state.attraction * (1 + prog * 2);
        p.vx += (dx / dist) * attract;
        p.vy += (dy / dist) * attract;

        if (state.mouse.active) {
          const mdx = p.x - state.mouse.x, mdy = p.y - state.mouse.y;
          const md = Math.hypot(mdx, mdy) || 1;
          if (md < 160) {
            const push = (1 - md/160) * 0.9;
            p.vx += (mdx / md) * push;
            p.vy += (mdy / md) * push;
          }
        }

        const jitter = state.jitter * (1 - prog * 0.7);
        p.vx += rand(-jitter, jitter);
        p.vy += rand(-jitter, jitter);

        p.vx *= state.drag;
        p.vy *= state.drag;
        p.x += p.vx;
        p.y += p.vy;
        p.rot += p.rotSpd;
      }

      function draw(p) {
        const elapsed = performance.now() - state.start;
        const prog = Math.min(elapsed / state.formationMs, 1);
        const isAIKW = 'AIKW'.includes(p.char);

        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        if (isAIKW) {
          const glow = (p.glow && prog > 0.5) ? 0.25 + prog * 0.5 : 0;
          ctx.font = `900 ${p.size}px \"Space Grotesk\", \"Arial Black\", monospace`;
          if (glow > 0) {
            ctx.shadowColor = `rgba(138,141,255,${glow})`;
            ctx.shadowBlur = p.size * 0.45;
          } else {
            ctx.shadowBlur = 0;
          }
          ctx.fillStyle = `rgba(180,186,255,${p.op})`;
          ctx.fillText(p.char, 0, 0);
        } else {
          ctx.font = `${p.size}px \"Space Grotesk\", monospace`;
          ctx.fillStyle = `rgba(241,241,241,${0.7*p.op})`;
          ctx.fillText(p.char, 0, 0);
        }

        ctx.restore();
      }

      function tick() {
        const w = canvas.width / dpr();
        const h = canvas.height / dpr();
        ctx.fillStyle = `rgba(5,6,10,${state.bgAlpha})`;
        ctx.fillRect(0, 0, w, h);
        state.particles.forEach(p => { update(p); draw(p); });
        requestAnimationFrame(tick);
      }

      function onPointer(e) {
        const r = canvas.getBoundingClientRect();
        state.mouse.x = e.clientX - r.left;
        state.mouse.y = e.clientY - r.top;
        state.mouse.active = true;
      }
      function onLeave() { state.mouse.active = false; }

      window.addEventListener('resize', resize);
      window.addEventListener('mousemove', onPointer);
      window.addEventListener('mouseleave', onLeave);
      window.addEventListener('touchmove', (ev) => { const t = ev.touches[0]; if (t) onPointer(t); }, { passive: true });
      window.addEventListener('touchend', onLeave);

      resize();
      requestAnimationFrame(tick);
    </script>
  </body>
</html>
